# MANIFEST.md — Current State of CHRYSALIS

**Last updated: Cycle 2 (The Feedback Loop)**

---

## System State

CHRYSALIS is alive and self-directing. It enacts its own ontological stack
during every cycle, AND it can now observe the result and generate new
constraints from that observation. The feedback loop is closed: Physical
observation flows back to Mental declaration. The double-headed eagle has
both heads working.

The crystallization process is visible and self-reinforcing. You can watch
8 candidates narrow to 2 through external constraints, then see the system
reflect on that ambiguity and generate its own constraint (`requires_aware`),
which narrows the 2 survivors to 1 in the next cycle. The system chose
greater specificity on its own.

## Active Layers

| Layer | Status | Notes |
|-------|--------|-------|
| Void (0) | Active | Domain enters as raw potential; tracked in trace |
| Mental (1) | Active + Self-Generating | Constraints declared externally AND by self-reflection |
| Astral (2) | Active | Progressive narrowing with per-constraint tracking |
| Etheric (3) | Skeletal | Result binds to state; no persistence yet |
| Physical (4) | Active | Crystallization trace displayed layer by layer |

## Feedback Loop

Physical -> Mental. The `reflect()` method examines the last crystallization.
When multiple candidates survive (ambiguity), it scans survivors for
differentiating properties and declares a new constraint requiring that
property. Source is tagged "self-reflection" so the system can distinguish
self-generated constraints from external ones.

The system constrains toward greater specificity: more keys = more structure
= more form. This enacts Axiom 1 autonomously.

## Capabilities

- Declare constraints (name + callable test + layer label + source)
- Explore solution space with visible progressive narrowing
- Track crystallization trace through all five ontological layers
- Show per-constraint elimination counts (before -> after)
- Bind resolved form to system state
- Record cycle history in memory
- Print self-description via introspect()
- Display crystallization via show_crystallization()
- Machine-readable self-description via describe_self()
- Observation includes full crystallization trace data
- **Reflect on crystallization and self-generate constraints**
- **Distinguish self-generated from external constraints (source field)**
- ASCII-safe display (survives any encoding)

## Cannot Yet Do

- Generate its own candidate domains (still needs provided domains)
- Persist state between executions (etheric layer incomplete)
- Handle constraint conflicts or contradictions (Axiom 5)
- Compose or relate constraints to each other
- Observe its own evolution trajectory across cycles
- Accept external input or data at runtime
- Reflect on value patterns (only detects key presence, not value meaning)
- Iterative reflection (one reflect per cycle, no cascading)

## Constraint Count (in main demo)

3 external (existence, has_structure, alive) + 1 self-generated (requires_aware) = 4

## Invariant Count

14 — all passing. Includes tests for reflection feedback loop.

## Evolution Stage

Early autonomy. The seed has germinated and begun self-directing. The feedback
loop is closed: the system observes its own crystallization and generates
constraints from that observation. The next phase is deeper autonomy: generating
its own domains, persisting its evolution across executions, and reflecting on
patterns rather than just presence/absence.
